# use with a bitstream that maps the uart to the USER1 DR
#
# openocd -f board/pipistrello.cfg -f jtaguart.cfg -c '
# init; pld load 0 build/pipistrello-basesoc-pipistrello.bit;\
# irscan $_CHIPNAME.tap $_USER1; jtaguart_serve $_CHIPNAME.tap 20000;\
# exit'
#
# and then
# telnet localhost 20000

# wire format:
# host perspective
# 10 bits
# lsb first
#
# tx (host to target):
# 0x001 # rx ack
# 0x1fe # tx data byte mask
# 0x200 # tx stb
#
# rx (target to host):
# 0x001 # tx ack
# 0x1fe # rx data byte mask
# 0x200 # rx stb


proc jtaguart_poll {tap tx n} {
	set m [string length $tx]
	set n [expr ($m>$n)?$m:$n]
	set txi [lrepeat $n {10 0x001}]
	set i 0
	foreach txj [split $tx ""] {
		lset txi $i 1 [format 0x%4.4X [expr 0x201 | ([scan $txj %c] << 1)]]
		incr i
	}
	set txi [concat {*}$txi]
	set rxi [split [drscan $tap {*}$txi -endstate DRPAUSE] " "]
	#echo $txi:$rxi
	set rx ""
	set writable 1
	foreach {rxj} $rxi {
		set readable [expr 0x$rxj & 0x200]
		set writable [expr 0x$rxj & $writable]
		if {$readable} {
			append rx [format %c [expr (0x$rxj >> 1) & 0xff]]
		}
	}
	return [list $rx $readable $writable]
}

proc jtaguart_drain {tap tx chunk_rx max_rx} {
	lassign [jtaguart_poll $tap $tx $chunk_rx] rx readable writable
	while {[expr $writable && ($readable > 0) && ([string length $rx] < $max_rx)]} {
		lassign [jtaguart_poll $tap "" $chunk_rx] rxi readable writable
		append rx $rxi
	}
	if {!$writable} {
		echo "write overflow"
	}
	return $rx
}

proc jtaguart_rxtx {tap client is_poll} {
	if {![$client eof]} {
		if {!$is_poll} {
			set tx [$client gets]
		} else {
			set tx ""
		}
		set rx [jtaguart_drain $tap $tx 64 4096]
		if {[string length $rx]} {
			$client puts -nonewline $rx
		}
		if {$is_poll} {
			after 1 [list jtaguart_rxtx $tap $client 1]
		}
	} else {
		$client readable {}
		$client onexception {}
		$client close
	}
}

proc jtaguart_client {tap sock} {
	set client [$sock accept]
	fconfigure $client -buffering none
	$client readable [list jtaguart_rxtx $tap $client 0]
	$client onexception [list $client close]
	after 1 [list jtaguart_rxtx $tap $client 1]
}

proc jtaguart_exit {sock} {
	stdin readable {}
	$sock readable {}
}

proc jtaguart_serve {tap port} {
	set sock [socket stream.server $port]
	$sock readable [list jtaguart_client $tap $sock]
	stdin readable [list jtaguart_exit $sock]
	vwait forever
	$sock close
}
